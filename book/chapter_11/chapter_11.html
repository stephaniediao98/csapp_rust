<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Network Programming</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Draft chapter</div></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_2.html"><strong aria-hidden="true">2.</strong> Representing and Manipulating Information</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Draft chapter</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Draft chapter</div></li><li class="chapter-item expanded "><a href="../chapter_5/chapter_5.html"><strong aria-hidden="true">5.</strong> Optimizing Program Performance</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Draft chapter</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Draft chapter</div></li><li class="chapter-item expanded "><a href="../chapter_8/chapter_8.html"><strong aria-hidden="true">8.</strong> Exceptional Control Flow</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Draft chapter</div></li><li class="chapter-item expanded "><a href="../chapter_10/chapter_10.html"><strong aria-hidden="true">10.</strong> System-Level I/O</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_10/section_1.html"><strong aria-hidden="true">10.1.</strong> Unix I/O</a></li><li class="chapter-item expanded "><a href="../chapter_10/section_2.html"><strong aria-hidden="true">10.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="../chapter_10/section_3.html"><strong aria-hidden="true">10.3.</strong> Opening and Closing Files</a></li><li class="chapter-item expanded "><a href="../chapter_10/section_4.html"><strong aria-hidden="true">10.4.</strong> Reading and Writing Files</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.5.</strong> Robust Reading and Writing with the Rio Package</div></li><li class="chapter-item expanded "><a href="../chapter_10/section_6.html"><strong aria-hidden="true">10.6.</strong> Reading File Metadata</a></li><li class="chapter-item expanded "><a href="../chapter_10/section_7.html"><strong aria-hidden="true">10.7.</strong> Reading Directory Contents</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.8.</strong> Sharing Files</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.9.</strong> I/O Redirection</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.10.</strong> Standard I/O (Omitted)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.11.</strong> Putting it Together: Which I/O Functions Should I Use?</div></li></ol></li><li class="chapter-item expanded "><a href="../chapter_11/chapter_11.html" class="active"><strong aria-hidden="true">11.</strong> Network Programming</a></li><li class="chapter-item expanded "><a href="../chapter_12/chapter_12.html"><strong aria-hidden="true">12.</strong> Concurrent Programming</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-11-network-programming"><a class="header" href="#chapter-11-network-programming">Chapter 11: Network Programming</a></h1>
<h2 id="the-client-server-programming-model"><a class="header" href="#the-client-server-programming-model">The Client-Server Programming Model</a></h2>
<h2 id="networks"><a class="header" href="#networks">Networks</a></h2>
<h2 id="the-global-ip-internet"><a class="header" href="#the-global-ip-internet">The Global IP Internet</a></h2>
<h3 id="ip-addresses"><a class="header" href="#ip-addresses">IP Addresses</a></h3>
<p>An IP address is an unsigned 32-bit integer. Rust defines the <em>IP address</em> struct shown below for network programs to store IP addresses. Storing IP addresses in a structure like this allows for us to more easily break the address into parts, manipulate it, and perform conversions on it.</p>
<pre><code class="language-rust ignore">pub struct Ipv4Addr {
    inner: c::in_addr,
}

impl Ipv4Addr {
    pub const fn new(a: u8, b: u8, c: u8, d: u8) -&gt; Ipv4Addr {
        // `s_addr` is stored as BE on all machine and the array is in BE order.
        // So the native endian conversion method is used so that it's never swapped.
        Ipv4Addr { inner: c::in_addr { s_addr: u32::from_ne_bytes([a, b, c, d]) } }
    }

    pub const fn octets(&amp;self) -&gt; [u8; 4] {
        // This returns the order we want because s_addr is stored in big-endian.
        self.inner.s_addr.to_ne_bytes()
    }
}
</code></pre>
<p>To ensure that IP addresses are usable consistently across both big-endian and little-endian systems, TCP/IP standardized that the encoding for IP addresses (and indeed, all network traffic) should be <em>big-endian</em>. This is also called <em>network byte order</em>. To enforce this invariant in our Rust code, the implementation of the IP address struct uses a rather obscure function: <code>u32::from_ne_bytes</code>. This function creates a 32-bit integer from a series of one-byte integers (<code>u8</code>). To do so, it assumes that the series of bytes that are passed to it are already in the proper increasing order based on the system's endianness: on a bit-endian system it assumes that the first byte passed is the most significant byte, and on a little-endian system it assumes that the first byte passed is the least significant byte. This ensures that when the final address is placed into memory, it will always be stored in big-endian representation if the bytes are passed in the order that humans typically read an IP address. If we want to get the bytes back in the correct network byte order, we can use the <code>#octets</code> method on the IP address struct.</p>
<h3 id="internet-domain-names"><a class="header" href="#internet-domain-names">Internet Domain Names</a></h3>
<h2 id="the-sockets-interface"><a class="header" href="#the-sockets-interface">The Sockets Interface</a></h2>
<p>The sockets interface is a set of functions that are used in conjunction with the Unix I/O functions to build network applications. It has been implemented on most modern systems, including all Unix variants as well as Windows and Macintosh systems. Below is an overview of the sockets interface in the context of a typical client-server transaction. Rust provides abstractions over top of the low-level sockets interface to make it even easier to set up network programming. Instead of going through each of the sockets interface functions individually, we will go through the main functions used in Rust to create and use sockets and explain which functions of the sockets interface are used under-the-hood.
<img src="../chapter_11/image1.png" alt="image" /></p>
<h3 id="socket-address-structures"><a class="header" href="#socket-address-structures">Socket Address Structures</a></h3>
<p>From the perspective of the Linux kernel, a socket is an endpoint for communication. From the perspective of a Linux program, a socket is an open file with a corresponding descriptor.</p>
<p>Internet socket addresses are stored in Rust in the <code>SocketAddrV4</code> struct. Internally, this struct stores the C representation of a socket address, called a <code>sockaddr_in</code>. The details of this C struct can be found below.</p>
<pre><code class="language-rust ignore">/* IP socket address structure */
struct sockaddr_in {
    uint16_t        sin_family;     /* Protocol family (aslways AF_INET) */
    uint16_t        sin_port;       /* Port number in network byte order */
    struct in_addr  sin_addr;       /* IP address in network byte order */
    unsigned char   sin_zero[8];    /* Pad to sizeof(struct sockaddr) */
};

/* Generic socket address structure (for connect, bind, and accept) */
struct sockaddr {
    uint16_t    sa_family;      /* Protocol family */
    char        sa_data[14];    /* Address data */
};
</code></pre>
<p>A socket address includes at least a <strong>family</strong> (always <code>AF_INET</code> for IP addresses), an <strong>address</strong> (a 32-bit IP address), and a <strong>port</strong>. Most of the time, you won't create the <code>SocketAddrV4</code> directly. Rust provides a trait called <code>ToSocketAddrs</code> that allow other, more common values (such as <code>&amp;str</code>) to be converted to <code>SocketAddrV4</code>. For the content in this book, we will use <code>&amp;str</code>s to represent our addresses and ports in a common and readable format used in networking.</p>
<h3 id="the-tcplistener-struct"><a class="header" href="#the-tcplistener-struct">The <code>TcpListener</code> Struct</a></h3>
<p>One of the most common ways to implement network programming in Rust is via paired objects known as <code>TcpStreams</code> and <code>TcpListeners</code>. The latter of these two acts as a server: it <em>listens</em> for incoming connections and allows them to be accepted in turn. Naturally, this kind of socket is called a listening socket, and the <code>TcpListener</code> uses some internal calls to the operating system that involve the <code>listen</code> function from the socket interface specification to indicate that this socket should stay passively open in the background, prepared to accept an incoming request.</p>
<h3 id="starting-the-server"><a class="header" href="#starting-the-server">Starting the Server</a></h3>
<p>Before we can address the specifics of making and accepting network connections in Rust, we'll provide some sample code that we can reference in the next few sections.</p>
<pre><code class="language-rust ignore">use std::net::TcpListener;
use std::io::{Read, Write, BufReader, BufRead};

pub fn make_socket() {
    let server = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap_or_else(|_| {
        panic!(&quot;Couldn't bind to port&quot;);
    });

    for connection in server.incoming() {
        println!(&quot;New connection!&quot;);

        let mut connection = match connection {
            Err(_) =&gt; {
                println!(&quot;Couldn't connect to client.&quot;);
                continue;
            },
            _ =&gt; connection.unwrap()
        };

        let mut string = String::new();
        let mut reader = BufReader::new(&amp;connection);
        if let Err(_) = reader.read_line(&amp;mut string) {
            println!(&quot;Unable to read from connection.&quot;);
            continue;
        }

        println!(&quot;From client: {}&quot;, string);

        let response = &quot;Hello!&quot;;
        if let Err(_) = connection.write_all(response.as_bytes()) {
            println!(&quot;Unable to write to connection.&quot;);
            continue;
        }

        println!(&quot;Connection closed.&quot;);
    }
}
</code></pre>
<p>The code above will create a new listening socket, allow connections to it, read one line of data (ending in <code>'\n'</code>) from the client, and then respond with the word <code>&quot;Hello!&quot;</code>.</p>
<p>Creating a new <code>TcpListener</code> and opening it to allow inbound connections can be done in one step in Rust, seen on line 5 of the example code above. There is a lot of heavy-lifting going on in this one line, so we'll go into more depth on what's actually happening there.</p>
<p>On that line, we call <code>TcpListener::bind</code> and pass it something that Rust knows how to interpret as a socket address. In this case, the common internet format of separating an IPv4 address and a TCP port with a colon is used. The address chosen, <code>127.0.0.1</code>, is a good choice since it works on any machine and only allows connections in from the same machine, which makes it very safe to use.</p>
<p>Internally, calling bind with this argument does the following:</p>
<ol>
<li>Splits the argument that it was given (<code>127.0.0.1:8080</code>) into a port and an address. If the IP address given is a <em>domain name</em> instead of an IP address (such as <code>www.example.com</code>),</li>
<li>Creates a new socket on the system via the <code>socket</code> method. It also specifies the type of address we are using (internally, <code>AF_INET</code> or 32-bit IPv4 addresses) and the type of connection to be  made (<code>SOCK_STREAM</code>, which corresponds to the TCP protocol).</li>
<li>Asks the system to <code>bind</code> this new socket to the address and port that we decoded in step 1.</li>
<li>Tells the system that we are now accepting new connections by calling the <code>listen</code> method.</li>
</ol>
<p>There is a lot of abstraction in this one function call! Each of these steps would have had to be taken separately in C. Now, we get to the interesting part: accepting new connections.
<br></p>
<p><span style="border: 1px solid #008bb2;
             border-radius: 5px;
             background-color: #60dcff;
             display: block;
             padding: 15px;
             color: #000833;">
<strong>Aside</strong>   127.0.0.1 <br>
The Internet has many organizations that govern it, and the one that deals specifically with the way that IP addresses are assigned and allocated is called <strong>IANA</strong>, or the <strong>Internet Assigned Numbers Authority</strong>. IANA has divided up the IPv4 address space into many different blocks, each of which has specific uses. Addresses of the form <code>10.x.x.x</code>, <code>172.y.x.x</code> (where <code>y</code> is between 16 and 31, inclusive), or <code>192.168.x.x</code>, for example, aren't routable on the public internet — they are for private use only. One of the better-known special blocks of IP addresses is the set of all addresses of the from <code>127.x.x.x</code>, specifically <code>127.0.0.1</code> with the alias &quot;<code>localhost</code>&quot;. On nearly every networked machine, this address is configured to route back to the machine itself. This is of great use to developers who are running code that runs over a network on their own computers, since accessing this code doesn't require that they know their IP address on the network (nor that they be on a network at all). They can reach their own machine by simply connecting to <code>127.0.0.1</code> or <code>localhost</code>.
</span></p>
<h3 id="accepting-connections"><a class="header" href="#accepting-connections">Accepting Connections</a></h3>
<p>Now that we have converted our address and port into a form that the system can understand, created a new socket, bound it to the port and address that we wanted, and marked it as acceptign new connections, we have to actually process requests that come in. In the sample code, this occurs in the for loop beginning on line 9:</p>
<pre><code class="language-rust ignore">    for connection in server.incoming() {
        println!(&quot;New connection!&quot;);

        let mut connection = match connection {
            Err(_) =&gt; {
                println!(&quot;Couldn't connect to client.&quot;);
                continue;
            },
            _ =&gt; connection.unwrap()
        };

        let mut string = String::new();
        let mut reader = BufReader::new(&amp;connection);
        if let Err(_) = reader.read_line(&amp;mut string) {
            println!(&quot;Unable to read from connection.&quot;);
            continue;
        }

        println!(&quot;From client: {}&quot;, string);

        let response = &quot;Hello!&quot;;
        if let Err(_) = connection.write_all(response.as_bytes()) {
            println!(&quot;Unable to write to connection.&quot;);
            continue;
        }

        println!(&quot;Connection closed.&quot;);
    }
</code></pre>
<p>Iterating over <code>server.incoming()</code> is fundamentally the same as repeatedly calling <code>server.accept()</code>, which internally calls the accept function on the socket interface. A nearly equivalent way of writing this loop is as follows:</p>
<pre><code class="language-rust ignore">loop {
    let connection = server.accept();

    // loop body
}
</code></pre>
<p>In either case, this function call blocks the program from continuing to work until a new connection is available. At this point, there are two different sockets that our program is dealing with: the socket attached to the newly-connected client, and the listener, which remains available for new connections.</p>
<p>Once we have our new connection, the iterator will yield a <code>TcpStream</code>.</p>
<p><span style="border: 1px solid #008bb2;
             border-radius: 5px;
             background-color: #60dcff;
             display: block;
             padding: 15px;
             color: #000833;">
<strong>Aside</strong>   <code>incoming()</code> versus <code>accept()</code>
When we accept an incoming connection by using <code>TcpListener#accept</code>, we are actually returned a tuple of two values: the new <code>TcpStream</code> itself and the <code>SocketAddress</code> identifying the client. When we iterate over incoming connections using <code>TcpListener#incoming</code>, we only get the client <code>TcpStream</code>. Often, when we are handling an incoming connection, where the connection came from is not important, so it's not necessary to have the <code>SocketAddr</code> of the client. In other situations, especially where security is a concern, this is a very important piece of information, and <code>TcpListener#accept</code> should be used over <code>TcpListener#incoming</code>.
</span></p>
<h3 id="connecting-to-a-listener"><a class="header" href="#connecting-to-a-listener">Connecting to a Listener</a></h3>
<p>Now that we know how to set up a listener of our own, it's time to explore the other side of the process: creating a client that could connect to our listener. Thankfully, this process is even simpler than creating the listener. Some example code that we will reference is below:</p>
<pre><code class="language-rust ignore">use std::net::TcpStream;
use std::io::{Write, Read};

pub fn make_connection() {
    let mut connection = match TcpStream::connect(&quot;127.0.0.1:8080&quot;) {
        Err(_) =&gt; {
            println!(&quot;Couldn't connect to server.&quot;);
            return;
        },
        Ok(connection) =&gt; connection
    };

    let to_send = &quot;Here's a line of data!\n&quot;;
    if let Err(_) = connection.write_all(to_send.as_bytes()) {
        println!(&quot;Unable to write to connection.&quot;);
        return;
    }

    let mut received: Vec&lt;u8&gt; = vec![];
    if let Err(_) = connection.read_to_end(&amp;mut received) {
        println!(&quot;Unable to read from connection.&quot;);
        return;
    }

    let mut received_string = match String::from_utf8(received) {
        Err(_) =&gt; {
            println!(&quot;Server sent non-UTF8 response.&quot;);
            return;
        },
        Ok(str) =&gt; str
    };

    println!(&quot;From server: {}&quot;, received_string);
}
</code></pre>
<p>To connect to a listener that already exists, we use the <code>TcpStream::connect</code> method found on line 5 of the code above. As one might expect, this calls the corresponding socket interface <code>connect</code> method to solidify that this socket is a client socket, and to cause the operating system to finalize making a connection to the requested destination.</p>
<h2 id="putting-it-together-the-span-stylefont-variant-small-capstinyspan-web-server"><a class="header" href="#putting-it-together-the-span-stylefont-variant-small-capstinyspan-web-server">Putting It Together: The <span style="font-variant: small-caps;">Tiny</span> Web Server</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../chapter_10/section_7.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../chapter_12/chapter_12.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../chapter_10/section_7.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../chapter_12/chapter_12.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
